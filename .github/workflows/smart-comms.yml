name: Smart Comms

on:
  schedule:
    - cron: '5 8 * * *'
    - cron: '27 10 * * *'
    - cron: '46 13 * * *'
    - cron: '15 16 * * *'
    - cron: '33 19 * * *'
    - cron: '50 22 * * *'
    - cron: '12 23 * * *'
  workflow_dispatch:

jobs:
  commit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 

      - name: Configure Git User
        run: |
          git config --global user.name "barendan"
          git config --global user.email "barendan@gmail.com"

      - name: Validate Repository Structure
        id: validate_structure
        run: |
          # Check if the snippets file exists
          if [ ! -f "src/components/snippets.txt" ]; then
            echo "Creating empty snippets file"
            mkdir -p src/components
            echo "// Sample comment" > src/components/snippets.txt
            echo "// Another line" >> src/components/snippets.txt
            echo "===" >> src/components/snippets.txt
            echo "/* Block comment */" >> src/components/snippets.txt
            echo "===" >> src/components/snippets.txt
          fi
          
          # Ensure src directory exists
          if [ ! -d "src" ]; then
            echo "Creating basic directory structure"
            mkdir -p src/components src/utils src/hooks
            echo "// Sample file" > src/components/App.js
            echo "// Sample file" > src/utils/helpers.js
            echo "// Sample file" > src/hooks/useFetch.js
          fi
          
          echo "repository_validated=true" >> $GITHUB_OUTPUT

      - name: Choose Valid Files
        if: steps.validate_structure.outputs.repository_validated == 'true'
        id: choose_files
        run: |
          # Define potential files to modify (excluding README.md)
          FILES=(
            "src/components/App.js"
            "src/components/Dashboard/Dashboard.jsx"
            "src/components/Dashboard/displayContact.jsx"
            "src/components/Dashboard/listContacts.jsx"
            "src/utils/helpers.js"
            "src/hooks/useFetch.js"
            ".env"
            "package.json"
          )

          # Find non-empty files that exist
          VALID_FILES=()
          for file in "${FILES[@]}"; do
            if [ -s "$file" ]; then
              VALID_FILES+=("$file")
            fi
          done

          # Exit if no valid files
          if [ ${#VALID_FILES[@]} -eq 0 ]; then
            echo "No valid files found. Skipping commit."
            echo "valid_files_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "valid_files_found=true" >> $GITHUB_OUTPUT
          
          # Decide how many files to modify (1-3)
          NUM_FILES=$((1 + RANDOM % 3))
          if [ $NUM_FILES -gt ${#VALID_FILES[@]} ]; then
            NUM_FILES=${#VALID_FILES[@]}
          fi
          
          # Create a temporary file to store chosen files
          touch chosen_files.txt
          
          # Select random files
          SHUFFLED=($(printf "%s\n" "${VALID_FILES[@]}" | shuf))
          for i in $(seq 0 $((NUM_FILES-1))); do
            echo "${SHUFFLED[$i]}" >> chosen_files.txt
          done
          
          echo "Selected $(wc -l < chosen_files.txt) files for modification"

      - name: Generate Real-Looking Updates
        if: steps.choose_files.outputs.valid_files_found == 'true' && steps.validate_structure.outputs.repository_validated == 'true'
        id: generate_updates
        run: |
          #!/bin/bash -e

          echo "Starting script..."
          SNIPPET_FILE="src/components/snippets.txt"
          
          # Read the chosen files from the file created in the previous step
          CHOSEN_FILES=$(cat chosen_files.txt)
          echo "Files to modify: $CHOSEN_FILES"

          # Debug: Check if file exists and can be read
          echo "Checking for snippets file at: $SNIPPET_FILE"
          if [ ! -f "$SNIPPET_FILE" ]; then
            echo "ERROR: No snippets file found at $SNIPPET_FILE"
            ls -la src/components/
            exit 1
          fi
          echo "Snippets file exists"

          # Debug: Check chosen files
          echo "CHOSEN_FILES value: '$CHOSEN_FILES'"
          CHANGED_FILES=()

          for FILE in $CHOSEN_FILES; do
            echo "Processing file: $FILE"
            
            # Debug: Check if file exists and can be read
            if [ ! -f "$FILE" ]; then
              echo "ERROR: File $FILE doesn't exist"
              continue
            fi
            echo "File exists"
            
            FILE_TYPE="${FILE##*.}"
            echo "File type: $FILE_TYPE"
            
            if [[ "$FILE_TYPE" == "js" || "$FILE_TYPE" == "jsx" ]]; then
              CATEGORY="Code Update"
            elif [[ "$FILE" == "README.md" ]]; then
              CATEGORY="Docs Update"
            elif [[ "$FILE" == "package.json" ]]; then
              CATEGORY="Dependency Update"
            elif [[ "$FILE" == ".env" ]]; then
              CATEGORY="Config Change"
            else
              CATEGORY="General Improvement"
            fi
            echo "Category: $CATEGORY"
            
            # Debug: Check snippet extraction
            echo "Extracting snippet from $SNIPPET_FILE"
            SNIPPETS=$(awk '/===/{print "---"} !/===/' "$SNIPPET_FILE" | awk 'BEGIN{RS="---"} {print}' | shuf -n 1)
            echo "Extracted snippet: $SNIPPETS"
            
            # Debug: Check line count
            echo "Counting lines in $FILE"
            if [ ! -s "$FILE" ]; then
              echo "ERROR: File $FILE is empty"
              continue
            fi
            TOTAL_LINES=$(wc -l < "$FILE")
            echo "Total lines: $TOTAL_LINES"
            
            RANDOM_LINE=$((RANDOM % TOTAL_LINES + 1))
            echo "Selected line: $RANDOM_LINE"
            
            # Using quotes to handle spaces in snippet
            echo "Inserting snippet at line $RANDOM_LINE"
            sed -i "${RANDOM_LINE}i\\${SNIPPETS}" "$FILE"
            
            CHANGED_FILES+=("$FILE")
            echo "Added file to changed files list"
            
            # 20% chance to add a bug
            if [[ $((RANDOM % 5)) -eq 0 ]]; then
              echo "Adding debug statement to $FILE"
              echo "console.log('DEBUG: This will be removed');" >> "$FILE"
              echo "Bug introduced in $FILE"
              # Track this file in debug_files.txt
              echo "$FILE" >> debug_files.txt
            fi
          done

          # Debug: Check if any files were changed
          echo "Number of changed files: ${#CHANGED_FILES[@]}"
          if [ ${#CHANGED_FILES[@]} -eq 0 ]; then
            echo "ERROR: No files were modified. Exiting."
            echo "changes_made=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "Adding files to git: ${CHANGED_FILES[@]}"
          git add "${CHANGED_FILES[@]}"

          # Randomized commit message with task numbers
          TASK_NUMBER="TASK-$((100 + RANDOM % 900))"
          COMMIT_MESSAGES=(
            "$TASK_NUMBER - Refactored logic for better performance and maintainability."
            "$TASK_NUMBER - Optimized function to reduce execution time and improve efficiency."
            "$TASK_NUMBER - Added missing error handling to enhance system stability."
            "$TASK_NUMBER - Cleaned up redundant code and improved readability."
            "$TASK_NUMBER - Implemented a helper function for reusability across components."
            "$TASK_NUMBER - Fixed minor performance bottleneck affecting large data processing."
            "$TASK_NUMBER - Enhanced logging for better debugging and monitoring."
            "$TASK_NUMBER - Updated with necessary $CATEGORY changes."
            "$TASK_NUMBER - Adjusted $CATEGORY settings for production readiness."
            "$TASK_NUMBER - Removed deprecated code and replaced with newer implementation."
          )

          COMMIT_MSG="${COMMIT_MESSAGES[$RANDOM % ${#COMMIT_MESSAGES[@]}]}"
          echo "Committing with message: $COMMIT_MSG"
          git commit -m "$COMMIT_MSG"
          
          # Set output variable for changes made
          echo "changes_made=true" >> $GITHUB_OUTPUT

          # 40% chance to push a quick fix later
          if [[ $((RANDOM % 5)) -lt 2 ]]; then
            echo "Will fix debug logs later"
            echo "debug_fix=true" >> $GITHUB_OUTPUT
            sleep $((10 + RANDOM % 20))  # Shortened for testing
            
            echo "Removing debug statements"
            for DEBUG_FILE in "${CHANGED_FILES[@]}"; do
              sed -i '/DEBUG: This will be removed/d' "$DEBUG_FILE"
              git add "$DEBUG_FILE"
            done
            
            git commit -m "TASK-$((100 + RANDOM % 900)) - Removed unnecessary debug logs."
            echo "Debug fix committed"
          else
            echo "debug_fix=false" >> $GITHUB_OUTPUT
          fi

          echo "Script completed successfully"

      - name: Push Changes
        if: steps.generate_updates.outputs.changes_made == 'true'
        run: |
          # Try to push changes safely
          git pull --rebase origin master || true
          git push
          
          # If push fails due to conflicts, try a safer approach
          if [ $? -ne 0 ]; then
            echo "Push failed, trying to recover..."
            # Save our changes
            git format-patch -1 HEAD -o temp_patches
            
            # Get the latest code
            git fetch origin master
            git reset --hard origin/master
            
            # Try to apply our changes
            if git apply --check temp_patches/* 2>/dev/null; then
              # If it would apply cleanly, do it
              git apply temp_patches/*
              git add .
              git commit -m "$(cat temp_patches/0001-*.patch | grep -m 1 'Subject:' | sed 's/Subject: //')"
              git push
            else
              echo "Could not apply changes cleanly. Manual intervention required."
              exit 1
            fi
          fi

      - name: Fix Debug Logs (if needed)
        if: steps.generate_updates.outputs.debug_fix == 'true'
        run: |
          # Wait a random amount of time (5-10 minutes)
          sleep $((300 + RANDOM % 300))
          
          # Remove debug statements from each file that had them
          while IFS= read -r DEBUG_FILE; do
            if [ -f "$DEBUG_FILE" ]; then
              sed -i '/DEBUG: This will be removed/d' "$DEBUG_FILE"
              git add "$DEBUG_FILE"
            fi
          done < debug_files.txt
          
          # Create a new commit for the debug fix
          if [ -n "$(git status --porcelain)" ]; then
            TASK_NUMBER="TASK-$((100 + RANDOM % 900))"
            git commit -m "$TASK_NUMBER - Removed unnecessary debug logs."
            
            # Push the fix
            git pull --rebase origin master
            git push
          fi