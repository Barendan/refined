name: Smart Comms

on:
  schedule:
    - cron: '5 8 * * *'
    - cron: '27 10 * * *'
    - cron: '46 13 * * *'
    - cron: '15 16 * * *'
    - cron: '33 19 * * *'
    - cron: '50 22 * * *'
    - cron: '12 23 * * *'
  workflow_dispatch:

jobs:
  commit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper checks

      - name: Configure Git User
        run: |
          git config --global user.name "barendan"
          git config --global user.email "barendan@gmail.com"

      - name: Check for Recent Commits
        id: check_commits
        run: |
          # Check if there have been commits in the last 2 hours
          LAST_COMMIT_TIME=$(git log -1 --format=%ct)
          CURRENT_TIME=$(date +%s)
          TIME_DIFF=$((CURRENT_TIME - LAST_COMMIT_TIME))
          
          if [ $TIME_DIFF -lt 7200 ]; then
            echo "Recent commit found, skipping automated changes"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "No recent commits, proceeding with changes"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Choose Valid Files
        if: steps.check_commits.outputs.skip != 'true'
        id: choose_files
        run: |
          # Define potential files to modify (excluding README.md)
          FILES=(
            "src/components/App.js"
            "src/components/Dashboard/Dashboard.jsx"
            "src/components/Dashboard/displayContact.jsx"
            "src/components/Dashboard/listContacts.jsx"
            "src/utils/helpers.js"
            "src/hooks/useFetch.js"
            ".env"
            "package.json"
          )

          # Find non-empty files that exist
          VALID_FILES=()
          for file in "${FILES[@]}"; do
            if [ -s "$file" ]; then
              VALID_FILES+=("$file")
            fi
          done

          # Exit if no valid files
          if [ ${#VALID_FILES[@]} -eq 0 ]; then
            echo "No valid files found. Skipping commit."
            echo "valid_files_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "valid_files_found=true" >> $GITHUB_OUTPUT
          
          # Decide how many files to modify (1-3)
          NUM_FILES=$((1 + RANDOM % 3))
          if [ $NUM_FILES -gt ${#VALID_FILES[@]} ]; then
            NUM_FILES=${#VALID_FILES[@]}
          fi
          
          # Create a temporary file to store chosen files
          touch chosen_files.txt
          
          # Select random files
          SHUFFLED=($(printf "%s\n" "${VALID_FILES[@]}" | shuf))
          for i in $(seq 0 $((NUM_FILES-1))); do
            echo "${SHUFFLED[$i]}" >> chosen_files.txt
          done
          
          echo "Selected $(wc -l < chosen_files.txt) files for modification"

      - name: Generate Real-Looking Updates
        if: steps.check_commits.outputs.skip != 'true' && steps.choose_files.outputs.valid_files_found == 'true'
        id: generate_updates
        run: |
          SNIPPET_FILE="src/components/snippets.txt"

          # Check if snippets file exists without trying to create it
          if [ ! -f "$SNIPPET_FILE" ]; then
            echo "No snippets file found! Exiting..."
            exit 1
          fi

          # Convert space-separated CHOSEN_FILES to array
          IFS=' ' read -ra FILES_ARRAY <<< "$CHOSEN_FILES"
          CHANGED_FILES=()
          DEBUG_FILES=()

          # Process each chosen file
          for FILE in "${FILES_ARRAY[@]}"; do
            if [ ! -f "$FILE" ]; then
              echo "File $FILE doesn't exist, skipping..."
              continue
            fi

            FILE_TYPE="${FILE##*.}"
            
            if [[ "$FILE_TYPE" == "js" || "$FILE_TYPE" == "jsx" ]]; then
              CATEGORY="Code Update"
            elif [[ "$FILE" == "package.json" ]]; then
              CATEGORY="Dependency Update"
            elif [[ "$FILE" == ".env" ]]; then
              CATEGORY="Config Change"
            else
              CATEGORY="General Improvement"
            fi
            
            # Get a random snippet
            IFS=$'\n' read -d '' -r -a SNIPPETS < <(awk '/===/{print "---"} !/===/' "$SNIPPET_FILE" | awk 'BEGIN{RS="---"} {print}' | shuf -n 1)
            CHOSEN_SNIPPET="${SNIPPETS[@]}"
            
            # Insert snippet at random location
            TOTAL_LINES=$(wc -l < "$FILE")
            if [ $TOTAL_LINES -gt 0 ]; then
              RANDOM_LINE=$((RANDOM % TOTAL_LINES + 1))
              sed -i "${RANDOM_LINE}i $CHOSEN_SNIPPET" "$FILE"
              
              CHANGED_FILES+=("$FILE")
              
              # 20% chance to add a bug
              if [[ $((RANDOM % 5)) -eq 0 ]]; then
                echo "console.log('DEBUG: This will be removed');" >> "$FILE"
                DEBUG_FILES+=("$FILE")
                echo "Bug introduced in $FILE"
              fi
            fi
          done

          # Only proceed if we have changes
          if [ ${#CHANGED_FILES[@]} -eq 0 ]; then
            echo "No files were modified. Exiting."
            exit 0
          fi

          git add "${CHANGED_FILES[@]}"

          # Randomized commit message with task numbers
          TASK_NUMBER="TASK-$((100 + RANDOM % 900))"
          COMMIT_MESSAGES=(
            "$TASK_NUMBER - Refactored logic for better performance and maintainability."
            "$TASK_NUMBER - Optimized function to reduce execution time and improve efficiency."
            "$TASK_NUMBER - Added missing error handling to enhance system stability."
            "$TASK_NUMBER - Cleaned up redundant code and improved readability."
            "$TASK_NUMBER - Implemented a helper function for reusability across components."
            "$TASK_NUMBER - Fixed minor performance bottleneck affecting large data processing."
            "$TASK_NUMBER - Enhanced logging for better debugging and monitoring."
            "$TASK_NUMBER - Updated with necessary $CATEGORY changes."
            "$TASK_NUMBER - Adjusted $CATEGORY settings for production readiness."
            "$TASK_NUMBER - Removed deprecated code and replaced with newer implementation."
          )

          COMMIT_MSG="${COMMIT_MESSAGES[$RANDOM % ${#COMMIT_MESSAGES[@]}]}"
          git commit -m "$COMMIT_MSG"

          # 40% chance to push a quick fix later if we added debug statements
          if [[ ${#DEBUG_FILES[@]} -gt 0 && $((RANDOM % 5)) -lt 2 ]]; then
            echo "Will do a debug fix later..."
            sleep $((300 + RANDOM % 600))
            
            # Remove debug statements from all files that had them
            for DEBUG_FILE in "${DEBUG_FILES[@]}"; do
              sed -i '/DEBUG: This will be removed/d' "$DEBUG_FILE"
              git add "$DEBUG_FILE"
            done
            
            git commit -m "TASK-$((100 + RANDOM % 900)) - Removed unnecessary debug logs."
            git push
          fi

      - name: Push Changes
        if: steps.generate_updates.outputs.changes_made == 'true'
        run: |
          # Try to push changes safely
          git pull --rebase origin master
          git push
          
          # If push fails due to conflicts, try again with updated code
          if [ $? -ne 0 ]; then
            echo "Push failed, trying to recover..."
            git reset --hard origin/master
            
            # Re-apply our changes to the latest code
            git apply --reject --whitespace=fix $(git format-patch -1 HEAD)
            
            # Commit and push again
            git add .
            git commit -m "$(git log -1 --pretty=%B)"
            git push
          fi

      - name: Fix Debug Logs (if needed)
        if: steps.generate_updates.outputs.debug_fix == 'true'
        run: |
          # Wait a random amount of time (5-10 minutes)
          sleep $((300 + RANDOM % 300))
          
          # Remove debug statements from each file that had them
          while IFS= read -r DEBUG_FILE; do
            if [ -f "$DEBUG_FILE" ]; then
              sed -i '/DEBUG: This will be removed/d' "$DEBUG_FILE"
              git add "$DEBUG_FILE"
            fi
          done < debug_files.txt
          
          # Create a new commit for the debug fix
          if [ -n "$(git status --porcelain)" ]; then
            TASK_NUMBER="TASK-$((100 + RANDOM % 900))"
            git commit -m "$TASK_NUMBER - Removed unnecessary debug logs."
            
            # Push the fix
            git pull --rebase origin master
            git push
          fi